#include <string>        // for basic_string, string
#include <utility>       // for pair
#include "Containers.h"  // for unordered_map
#include "TokenType.h"   // for TokenType


namespace epi {

extern const cotyl::unordered_map<const std::string, TokenType> Keywords = {
        { "auto",           TokenType::Auto },
        { "break",          TokenType::Break },
        { "case",           TokenType::Case },
        { "char",           TokenType::Char },
        { "const",          TokenType::Const },
        { "continue",       TokenType::Continue },
        { "default",        TokenType::Default },
        { "do",             TokenType::Do },
        { "double",         TokenType::Double },
        { "else",           TokenType::Else },
        { "enum",           TokenType::Enum },
        { "extern",         TokenType::Extern },
        { "float",          TokenType::Float },
        { "for",            TokenType::For },
        { "goto",           TokenType::Goto },
        { "if",             TokenType::If },
        { "inline",         TokenType::Inline },
        { "int",            TokenType::Int },
        { "long",           TokenType::Long },
        { "register",       TokenType::Register },
        { "restrict",       TokenType::Restrict },
        { "return",         TokenType::Return },
        { "short",          TokenType::Short },
        { "signed",         TokenType::Signed },
        { "sizeof",         TokenType::Sizeof },
        { "static",         TokenType::Static },
        { "struct",         TokenType::Struct },
        { "switch",         TokenType::Switch },
        { "typedef",        TokenType::Typedef },
        { "union",          TokenType::Union },
        { "unsigned",       TokenType::Unsigned },
        { "void",           TokenType::Void },
        { "volatile",       TokenType::Volatile },
        { "while",          TokenType::While },
        { "_Alignas",       TokenType::Alignas },
        { "_Alignof",       TokenType::Alignof },
        { "_Atomic",        TokenType::Atomic },
        { "_Bool",          TokenType::Bool },
        { "_Complex",       TokenType::Complex },
        { "_Generic",       TokenType::Generic },
        { "_Imaginary",     TokenType::Imaginary },
        { "_Noreturn",      TokenType::Noreturn },
        { "_Static_assert", TokenType::StaticAssert },
        { "_Thread_local",  TokenType::ThreadLocal },
};

extern const cotyl::unordered_map<const std::string, TokenType> Punctuators = {
    { "[",   TokenType::LBracket },
    { "]",   TokenType::RBracket },
    { "(",   TokenType::LParen },
    { ")",   TokenType::RParen },
    { "{",   TokenType::LBrace },
    { "}",   TokenType::RBrace },
    { ".",   TokenType::Dot },
    { "->",  TokenType::Arrow },
    { "++",  TokenType::Incr },
    { "--",  TokenType::Decr },
    { "&",   TokenType::Ampersand },
    { "*",   TokenType::Asterisk },
    { "+",   TokenType::Plus },
    { "-",   TokenType::Minus },
    { "~",   TokenType::Tilde },
    { "!",   TokenType::Exclamation },
    { "/",   TokenType::Div },
    { "%",   TokenType::Mod },
    { "<<",  TokenType::LShift },
    { ">>",  TokenType::RShift },
    { "<",   TokenType::Less },
    { ">",   TokenType::Greater },
    { "<=",  TokenType::LessEqual },
    { ">=",  TokenType::GreaterEqual },
    { "==",  TokenType::Equal },
    { "!=",  TokenType::NotEqual },
    { "^",   TokenType::BinXor },
    { "|",   TokenType::BinOr },
    { "&&",  TokenType::LogicalAnd },
    { "||",  TokenType::LogicalOr },
    { "?",   TokenType::Question },
    { ":",   TokenType::Colon },
    { ";",   TokenType::SemiColon },
    { "...", TokenType::Ellipsis },
    { "=",   TokenType::Assign },
    { "*=",  TokenType::IMul },
    { "/=",  TokenType::IDiv },
    { "%=",  TokenType::IMod },
    { "+=",  TokenType::IPlus },
    { "-=",  TokenType::IMinus },
    { "<<=", TokenType::ILShift },
    { ">>=", TokenType::IRShift },
    { "&=",  TokenType::IAnd },
    { "^=",  TokenType::IXor },
    { "|=",  TokenType::IOr },
    { ",",   TokenType::Comma },
    { "#",   TokenType::Hashtag },
    { "##",  TokenType::HHashtag },
};


extern const cotyl::unordered_map<TokenType, std::string> TokenNames = {
        { TokenType::Auto, { "auto" /* Keyword */ } },
        { TokenType::Break, { "break" /* Keyword */ } },
        { TokenType::Case, { "case" /* Keyword */ } },
        { TokenType::Char, { "char" /* Keyword */ } },
        { TokenType::Const, { "const" /* Keyword */ } },
        { TokenType::Continue, { "continue" /* Keyword */ } },
        { TokenType::Default, { "default" /* Keyword */ } },
        { TokenType::Do, { "do" /* Keyword */ } },
        { TokenType::Double, { "double" /* Keyword */ } },
        { TokenType::Else, { "else" /* Keyword */ } },
        { TokenType::Enum, { "enum" /* Keyword */ } },
        { TokenType::Extern, { "extern" /* Keyword */ } },
        { TokenType::Float, { "float" /* Keyword */ } },
        { TokenType::For, { "for" /* Keyword */ } },
        { TokenType::Goto, { "goto" /* Keyword */ } },
        { TokenType::If, { "if" /* Keyword */ } },
        { TokenType::Inline, { "inline" /* Keyword */ } },
        { TokenType::Int, { "int" /* Keyword */ } },
        { TokenType::Long, { "long" /* Keyword */ } },
        { TokenType::Register, { "register" /* Keyword */ } },
        { TokenType::Restrict, { "restrict" /* Keyword */ } },
        { TokenType::Return, { "return" /* Keyword */ } },
        { TokenType::Short, { "short" /* Keyword */ } },
        { TokenType::Signed, { "signed" /* Keyword */ } },
        { TokenType::Sizeof, { "sizeof" /* Keyword */ } },
        { TokenType::Static, { "static" /* Keyword */ } },
        { TokenType::Struct, { "struct" /* Keyword */ } },
        { TokenType::Switch, { "switch" /* Keyword */ } },
        { TokenType::Typedef, { "typedef" /* Keyword */ } },
        { TokenType::Union, { "union" /* Keyword */ } },
        { TokenType::Unsigned, { "unsigned" /* Keyword */ } },
        { TokenType::Void, { "void" /* Keyword */ } },
        { TokenType::Volatile, { "volatile" /* Keyword */ } },
        { TokenType::While, { "while" /* Keyword */ } },
        { TokenType::Alignas, { "_AlignAs" /* Keyword */ } },
        { TokenType::Alignof, { "_AlignOf" /* Keyword */ } },
        { TokenType::Atomic, { "_Atomic" /* Keyword */ } },
        { TokenType::Bool, { "_Bool" /* Keyword */ } },
        { TokenType::Complex, { "_Complex" /* Keyword */ } },
        { TokenType::Generic, { "_Generic" /* Keyword */ } },
        { TokenType::Imaginary, { "_Imaginary" /* Keyword */ } },
        { TokenType::Noreturn, { "_NoReturn" /* Keyword */ } },
        { TokenType::StaticAssert, { "_Static_assert" /* Keyword */ } },
        { TokenType::ThreadLocal, { "_Thread_local" /* Keyword */ } },
        { TokenType::LBracket, { "[" /* Punctuator */ } },
        { TokenType::RBracket, { "]" /* Punctuator */ } },
        { TokenType::LParen, { "(" /* Punctuator */ } },
        { TokenType::RParen, { ")" /* Punctuator */ } },
        { TokenType::LBrace, { "{" /* Punctuator */ } },
        { TokenType::RBrace, { "}" /* Punctuator */ } },
        { TokenType::Dot, { "." /* Punctuator */ } },
        { TokenType::Arrow, { "->" /* Punctuator */ } },
        { TokenType::Incr, { "++" /* Punctuator */ } },
        { TokenType::Decr, { "--" /* Punctuator */ } },
        { TokenType::Ampersand, { "&" /* Punctuator */ } },
        { TokenType::Asterisk, { "*" /* Punctuator */ } },
        { TokenType::Plus, { "+" /* Punctuator */ } },
        { TokenType::Minus, { "-" /* Punctuator */ } },
        { TokenType::Tilde, { "~" /* Punctuator */ } },
        { TokenType::Exclamation, { "!" /* Punctuator */ } },
        { TokenType::Div, { "/" /* Punctuator */ } },
        { TokenType::Mod, { "%" /* Punctuator */ } },
        { TokenType::LShift, { "<<" /* Punctuator */ } },
        { TokenType::RShift, { ">>" /* Punctuator */ } },
        { TokenType::Less, { "<" /* Punctuator */ } },
        { TokenType::Greater, { ">" /* Punctuator */ } },
        { TokenType::LessEqual, { "<=" /* Punctuator */ } },
        { TokenType::GreaterEqual, { ">=" /* Punctuator */ } },
        { TokenType::Equal, { "==" /* Punctuator */ } },
        { TokenType::NotEqual, { "!=" /* Punctuator */ } },
        { TokenType::BinXor, { "^" /* Punctuator */ } },
        { TokenType::BinOr, { "|" /* Punctuator */ } },
        { TokenType::LogicalAnd, { "&&" /* Punctuator */ } },
        { TokenType::LogicalOr, { "||" /* Punctuator */ } },
        { TokenType::Question, { "?" /* Punctuator */ } },
        { TokenType::Colon, { ":" /* Punctuator */ } },
        { TokenType::SemiColon, { ";" /* Punctuator */ } },
        { TokenType::Ellipsis, { "..." /* Punctuator */ } },
        { TokenType::Assign, { "=" /* Punctuator */ } },
        { TokenType::IMul, { "*=" /* Punctuator */ } },
        { TokenType::IDiv, { "/=" /* Punctuator */ } },
        { TokenType::IMod, { "%=" /* Punctuator */ } },
        { TokenType::IPlus, { "+=" /* Punctuator */ } },
        { TokenType::IMinus, { "-=" /* Punctuator */ } },
        { TokenType::ILShift, { "<<=" /* Punctuator */ } },
        { TokenType::IRShift, { ">>=" /* Punctuator */ } },
        { TokenType::IAnd, { "&=" /* Punctuator */ } },
        { TokenType::IXor, { "^=" /* Punctuator */ } },
        { TokenType::IOr, { "|=" /* Punctuator */ } },
        { TokenType::Comma, { "," /* Punctuator */ } },
        { TokenType::Hashtag, { "#" /* Punctuator */ } },
        { TokenType::HHashtag, { "##" /* Punctuator */ } },
};

}